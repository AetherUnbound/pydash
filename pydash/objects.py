"""Objects
"""

from __future__ import absolute_import

from .arrays import flatten
from .utils import iter_, iter_callback
from ._compat import iteritems, itervalues, iterkeys


def assign(obj, source, callback=None):
    """Assigns own enumerable properties of source object(s) to the destination
    object.
    """
    if isinstance(source, dict):
        source = [source]

    for src in source:
        for key, value in src.iteritems():
            if callback is None:
                obj[key] = value
            else:
                obj[key] = callback(obj.get(key, None), value)

    return obj


def keys(obj):
    """Creates a list composed of the keys of `obj`."""
    return list(iterkeys(obj))


def map_values(obj, callback=None):
    """Creates an object with the same keys as `obj` and values generated by
    running each property of `obj` through the `callback`. The callback is
    invoked with three arguments: (value, key, object). If a property name is
    provided for `callback` the created :func:`pluck` style callback will
    return the property value of the given element. If an object is provided
    for callback the created :func:`where` style callback will return `True`
    for elements that have the properties of the given object, else `False`.
    """
    ret = {}

    for result, _, key, _ in iter_callback(obj, callback):
        ret[key] = result

    return ret


def omit(obj, callback, *properties):
    """Creates a shallow clone of object excluding the specified properties.
    Property names may be specified as individual arguments or as lists of
    property names. If a callback is provided it will be executed for each
    property of object omitting the properties the callback returns truthy for.
    The callback is invoked with three arguments; (value, key, object).
    """
    if not callable(callback):
        properties = flatten([callback, properties])
        callback = lambda value, key, item: key in properties

    return dict((key, value) for key, value in iteritems(obj)
                if not callback(value, key, obj))


def pairs(obj):
    """Creates a two dimensional list of an object's key-value pairs, i.e.
    [[key1, value1], [key2, value2]].
    """
    return [[key, value] for key, value in iteritems(obj)]


def pick(obj, callback, *properties):
    """Creates a shallow clone of object composed of the specified properties.
    Property names may be specified as individual arguments or as lists of
    property names. If a callback is provided it will be executed for each
    property of object picking the properties the callback returns truthy for.
    The callback is invoked with three arguments; (value, key, object).
    """
    if not callable(callback):
        properties = flatten([callback, properties])
        callback = lambda value, key, *args: key in properties

    return dict((key, value) for key, value in iteritems(obj)
                if callback(value, key, obj))


def transform(obj, callback=None, accumulator=None):
    """An alternative to :func:`reduce`, this method transforms `obj` to a new
    accumulator object which is the result of running each of its properties
    through a callback, with each callback execution potentially mutating the
    accumulator object. The callback is invoked with four arguments:
    (accumulator, value, key, object). Callbacks may exit iteration early by
    explicitly returning `False`.
    """
    if callback is None:
        callback = lambda accumulator, *args: accumulator

    if accumulator is None:
        accumulator = []

    for key, value in iter_(obj):
        result = callback(accumulator, value, key, obj)
        if result is False:
            break

    return accumulator


def values(obj):
    """Creates a list composed of the values of `obj`."""
    return list(itervalues(obj))
